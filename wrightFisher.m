function x_vec = wrightFisher(N_pop, N_gen, x0, F, selection_type)
% x_vec = wrightFisher(N_pop, N_gen, x0, F, selection_type)
%
% This function simulates Wright-Fisher style dynamics, in which the
% population size remains fixed but the proportion of the population in
% different states (for example allelic values for a gene or phenotypes of
% individuals) changes from generation to generation. The proportions in 
% the new generation are generated by multinomial sampling according to
% probabilities that represent (optionally) the effects of selection and
% mutation, together with the natural tendency that alleles/phenotypes that
% are currently present in higher number in the population will be more
% likely to appear in the next.
%
% -Inputs-
%
%          N_pop: Number of individuals in the population
%                 Total number of individuals is 2N due to assumed diploidy
%
%          N_gen: The number of generations to simulate
%
%             x0: The initial state, a vector with number of components
%                 equal to the number of possible allelic values/phenotypes
%
%              F: A function defining fitness, of form    f = @(x)
%                      f is fitness, a vector the same length as x
%                      x is the current proportions in the population
%
%
% selection_type: Either a value of 1 or 2, corresponding to type I/II
%                 selection as described subsequently. If not provided,
%                 type I selection is chosen by default
%
% -Outputs-
%
%          x_vec: An Nx by N_gen+1 matrix, with Nx the length of x. This
%                 matrix represents the proportional makeup of the 
%                 population for each of the N_gen generations (plus the
%                 initial state)
%
% Fitness is implemented such that the baseline probabilities to appear in
% the next generation are given by element-wise product of f and x.
% For alleles, this choice corresponds to random mating, and
% "survival-based fitness" (i.e. fitness designates the probability of
% surviving to breeding age).
%
% Mutation is implemented as a final modifier to the probabilities to
% appear in the next generation. That is, expected proportions for the next
% generation are set according to current population make-up and fitness,
% and *then* mutation acts to potentially change these expected proportions
% in the individuals generated by reproduction.
%
% Selection is either "type I" or "type II". Fitness is defined by the
% input function F, but the type of selection changes how the fitness
% values are normalised to obtain probabilities for the next generation
% that sum to one. Denoting these probabilities p, Type I selection is:
%    p = ( f .* x - [x^T f - 1] x )
% Type II selection is:
%    p = ( f .* x ) / ( x^T f )

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Read out the number of alleles/features
N_feat = length(x0);
% Initial state is also the current state before any generations elapse
x = x0 / sum(x0);      % Ensure initial state is treated as proportions
% Assume type I selection if not specified
if nargin < 5
    selection_type = 1;
end

% Repeatedly iterate generations
x_vec = zeros(N_feat,N_gen+1);
x_vec(:,1) = x;
for k = 1:N_gen
    
    % Expected proportions for the next generation are current proportions,
    % weighted by fitness, and then normalised to sum to one 
    if selection_type == 1
        
        % Additive normalisation of fitness
        p = x .* (F(x) - (x' * F(x) - 1) * ones(size(x)) );
    
    else
        
        % Multiplicative normalisation of fitness
        p = (x .* F(x)) / (x' * F(x));
    
    end
    
    % Check if any expected proportions outside of [0,1] (w/ tolerance)
    adjust_tol = 1e-12;
    if any(p < -adjust_tol) || any(p > 1+adjust_tol)
        error('Current choice of fitness and selection produced inappropriate porportions. Check specification of both.');
    end

    % Numerical protection - project p onto the probability simplex
    p = projectOntoSimplex(p);
    
    % Sample from multinomial using the current population 
    C = mnrnd(N_pop, p)';
                
    % Convert counts back into proportions
    x = C / N_pop;
    
    % Track in a vector
    x_vec(:,k+1) = x;
    
end